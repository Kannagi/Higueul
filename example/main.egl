
.bss 0x2100
//SNES PPU
uint8 INIDISP;
uint8 OBJSEL;
uint16 OAMADD;
uint8 OAMDATA;
uint8 BGMODE;
uint8 MOSAIC;
uint8 BG1SC;
uint8 BG2SC;
uint8 BG3SC;
uint8 BG4SC;
uint8 BG12NBA;
uint8 BG34NBA;
uint8 BG1H0FS;
uint8 BG1V0FS;
uint8 BG2H0FS;
uint8 BG2V0FS;
uint8 BG3H0FS;
uint8 BG3V0FS;
uint8 BG4H0FS;
uint8 BG4V0FS;
uint8 VMAINC;
uint16 VMADD;
uint16 VMDATA;
uint8 M7SEL;
uint8 M7A;
uint8 M7B;
uint8 M7C;
uint8 M7D;
uint8 M7X;
uint8 M7Y;
uint8 CGADD;
uint8 CGDATA;
uint8 W12SEL;
uint8 W34SEL;
uint8 WOBJSEL;
uint8 WH0;
uint8 WH1;
uint8 WH2;
uint8 WH3;
uint8 WBGLOG;
uint8 WOBJLOG;
uint8 TM;
uint8 TS;
uint8 TMW;
uint8 TSW;
uint8 CGSWSEL;
uint8 CGADSUB;
uint8 COLDATA;
uint8 SETINI;
uint8 MPYL;
uint8 MPYM;
uint8 MPYH;
uint8 SLHV;

uint8 OAMDATAREAD;
uint8 VMDATALREAD;
uint8 VMDATAHREAD;
uint8 CGDATAREAD;

uint8 OPHCT;
uint8 OPVCT;
uint8 STAT77;
uint8 STAT78;

uint8 APUIO0;
uint8 APUIO1;
uint8 APUIO2;
uint8 APUIO3;

//WRAM
.bss 0x2180
uint8 WMDATA;
uint16 WMADD;
uint8 WMADDH;

.bss 0x4016
uint8 JOYSER0;
uint8 JOYSER1;

.bss 0x4200
//SNES IO
uint8 NMITIMEN;
uint8 WRIO;
uint8 WRMPYA;
uint8 WRMPYB;

uint8 WRDIVL;
uint8 WRDIVH;
uint8 WRDIVB;
uint8 HTIMEL;

uint8 HTIMEH;
uint8 VTIMEL;
uint8 VTIMEH;
uint8 MDMAEN;

uint8 HDMAEN;
uint8 MEMSEL;

uint8 MEMSEL1;
uint8 MEMSEL2;

uint8 RDNMI;
uint8 TIMEUP;
uint8 HVBJOY;
uint8 RDIO;

uint8 RDDIVL;
uint8 RDDIVH;
uint8 RDMPYL;
uint8 RDMPYH;
uint8 STDCONTROL1L;
uint8 STDCONTROL1H;
uint8 STDCONTROL2L;
uint8 STDCONTROL2H;
uint8 STDCONTROL3L;
uint8 STDCONTROL3H;
uint8 STDCONTROL4L;
uint8 STDCONTROL4H;

//DMA 0
.bss 0x4300
uint8 DMA_0;
uint8 DMA_BADD_0;
uint16 DMA_ADD_0;
uint8 DMA_BANK_0;
uint16 DMA_SIZE_0;

uint8 HDMA_BANK_0;
uint16 HDMA_ADD_0;
uint8 HDMA_LINE_0;

//DMA 1
.bss 0x4310
uint8 DMA_1;
uint8 DMA_BADD_1;
uint16 DMA_ADD_1;
uint8 DMA_BANK_1;
uint16 DMA_SIZE_1;

uint8 HDMA_BANK_1;
uint16 HDMA_ADD_1;
uint8 HDMA_LINE_1;


//DMA 2
.bss 0x4320
uint8 DMA_2;
uint8 DMA_BADD_2;
uint16 DMA_ADD_2;
uint8 DMA_BANK_2;
uint16 DMA_SIZE_2;

uint8 HDMA_BANK_2;
uint16 HDMA_ADD_2;
uint8 HDMA_LINE_2;

.bss 0x4330
uint8 DMA_3;
uint8 DMA_BADD_3;
uint16 DMA_ADD_3;
uint8 DMA_BANK_3;
uint16 DMA_SIZE_3;

uint8 HDMA_BANK_3;
uint16 HDMA_ADD_3;
uint8 HDMA_LINE_3;

.bss 0x4340
uint8 DMA_4;
uint8 DMA_BADD_4;
uint16 DMA_ADD_4;
uint8 DMA_BANK_4;
uint16 DMA_SIZE_4;

uint8 HDMA_BANK_4;
uint16 HDMA_ADD_4;
uint8 HDMA_LINE_4;

.bss 0x4350
uint8 DMA_5;
uint8 DMA_BADD_5;
uint16 DMA_ADD_5;
uint8 DMA_BANK_5;
uint16 DMA_SIZE_5;

uint8 HDMA_BANK_5;
uint16 HDMA_ADD_5;
uint8 HDMA_LINE_5;

.bss 0x4360
uint8 DMA_6;
uint8 DMA_BADD_6;
uint16 DMA_ADD_6;
uint8 DMA_BANK_6;
uint16 DMA_SIZE_6;

uint8 HDMA_BANK_6;
uint16 HDMA_ADD_6;
uint8 HDMA_LINE_6;

.bss 0x4370
uint8 DMA_7;
uint8 DMA_BADD_7;
uint16 DMA_ADD_7;
uint8 DMA_BANK_7;
uint16 DMA_SIZE_7;

uint8 HDMA_BANK_7;
uint16 HDMA_ADD_7;
uint8 HDMA_LINE_7;

.bss 0x7ED000
uint8 SNDK_OAM0.x;
uint8 SNDK_OAM0.y;
uint8 SNDK_OAM0.t;
uint8 SNDK_OAM0.a;

uint8 SNDK_OAM1.x;
uint8 SNDK_OAM1.y;
uint8 SNDK_OAM1.t;
uint8 SNDK_OAM1.a;

uint8 SNDK_OAM2.x;
uint8 SNDK_OAM2.y;
uint8 SNDK_OAM2.t;
uint8 SNDK_OAM2.a;

uint8 SNDK_OAM3.x;
uint8 SNDK_OAM3.y;
uint8 SNDK_OAM3.t;
uint8 SNDK_OAM3.a;

uint8 SNDK_OAML 0x1F0;
uint8 SNDK_OAMH 0x20;

uint8 SNDK_Bullet.i 14;
uint8 SNDK_Bullet.n 14;

uint8  SNDK.cpu,SNDK.mcpu,SNDK.pcpu;
uint8  SNDK.clockf,SNDK.clocks,SNDK.clockm,SNDK.clockh;

uint16 SNDK_BG1Scroll.x;
uint16 SNDK_BG1Scroll.y;
uint16 SNDK_BG2Scroll.x;
uint16 SNDK_BG2Scroll.y;

uint16 SNDK_SPRITE.x;
uint16 SNDK_SPRITE.y;
uint8 SNDK_SPRITE.t;
uint8 SNDK_SPRITE.a;
uint16 SNDK_SPRITE.vx;
uint16 SNDK_SPRITE.vy;
uint16 SNDK_SPRITE.vram;
uint8 SNDK_SPRITE.oam;
uint8 SNDK_SPRITE.address;
uint8 SNDK_SPRITE.ianim;
//4
uint16 SNDK_SPRITE.anim 0x400;

uint8 SNDK_BUF_BG1.h 0x40;
uint8 SNDK_BUF_BG1.v 0x40;

uint8 SNDK_BUF_BG2.h 0x40;
uint8 SNDK_BUF_BG2.v 0x40;

uint8 SNDK_Bullet.x 128;
uint8 SNDK_Bullet.y 128;
uint8 SNDK_Bullet.vx 128;
uint8 SNDK_Bullet.vy 128;
uint8 SNDK_BG3.t1;
uint8 SNDK_BG3.t2 0x800;

.bss 0x7F0000
uint8 SNDK_BufferBG1 0x4000;
uint8 SNDK_BufferBG2 0x4000;
uint8 SNDK_BufferCOL 0x2000;

uint8 SNDK_BufferSPR1 0x2000;
uint8 SNDK_BufferSPR2 0x2000;
uint8 SNDK_BufferSPR3 0x2000;

.bss 0xC0

.bss 0x7E2000
//--------------

.define OAM_XFLIP 0x80
.define OAM_YFLIP 0x40
.define OAM_PRIO0 0x00
.define OAM_PRIO1 0x10
.define OAM_PRIO2 0x20
.define OAM_PRIO3 0x30
.define OAM_PAL0 0x00
.define OAM_PAL1 0x02
.define OAM_PAL2 0x04
.define OAM_PAL3 0x06
.define OAM_PAL4 0x08
.define OAM_PAL5 0x0A
.define OAM_PAL6 0x0C
.define OAM_PAL7 0x0E
.define OAM_TILE 0x01

.define SNDK_PAD_B 0x80
.define SNDK_PAD_Y 0x40
.define SNDK_PAD_START 0x20
.define SNDK_PAD_SELECT 0x10
.define SNDK_PAD_UP 0x08
.define SNDK_PAD_DOWN 0x04
.define SNDK_PAD_LEFT 0x02
.define SNDK_PAD_RIGHT 0x01

.define SNDK_PAD_A 0x80
.define SNDK_PAD_X 0x40
.define SNDK_PAD_L 0x20
.define SNDK_PAD_R 0x10

.define SNDK_MODE1  0x39 // BG 1 & 2 16x16, BG 3 8x8,mode 1 , BG 3 pri
.define SNDK_MODE7  0x07

.define SNDK_FONTPAL0 0x20
.define SNDK_FONTPAL1 0x24
.define SNDK_FONTPAL2 0x28
.define SNDK_FONTPAL3 0x2C

//0,2,6, $6000 address Sprite
.define SNDK_SPR_8_16    0x03 
.define SNDK_SPR_8_32    0x23
.define SNDK_SPR_16_32  0x63

.define MODE8   asm "sep #$20";
.define MODE16 asm "rep #$20";


//-----------------

.macro SNES_HEADER
//ROM Header
.data.s "SNES SDK DEMO       ";
//      "1234567890123456789"
.data.b 0x30; //0x20 2.68 MHz / 0x30 3.58 MHz
.data.b 0x00; //ROM only
.data.b 0x09; //ROM size 1<<x kio 9 : 512 KB / 10 :1MB / 11 : 2MB / 12 : 4MB
.data.b 0x00; //RAM size 16<<(x-1) kio
.data.b 0x01; //0 = japan, 1 = usa , 2 = europe
.data.b 0x00; //ID extension
.data.b 0x00; //VERSION
.data.w 0x00; //checksum+
.data.w 0x00; //checksum-


//65816 vector
.data.l 0x00; //unused
.data.w SNES_ERROR; //COP
.data.w SNES_ERROR; //BRK
.data.w SNES_ERROR; //ABORT
.data.w VBlank; //NMI
.data.w 0x00; //RESET
.data.w SNES_IRQHV; //IRQ

//6502 vector
.data.l 0x00; //unused
.data.w SNES_ERROR; //COP
.data.w 0x00; //
.data.w SNES_ERROR; //ABORT
.data.w VBlank; //NMI
.data.w _start; //RESET
.data.w SNES_IRQHV; //IRQBRK
.endmacro

.funcmap 0x200
.funcmap.spm 0xF0
.funcmap.lib    0xE0
.map.spm 0x00
.map.lib 0x80
//0xD0 Register no use


.macro SNES_BANK

.org (0x8000*.arg1)
.rodata  ( 0x808000 +  0x10000*.arg1 )

.endmacro

//-----------------

.macro SNDK_memcopy

	WMADD = .arg1;
	WMADDH = .arg2
	;
	DMA_BANK_6 = .arg4;
	
	idy = .arg3;
	DMA_ADD_6 = idy;
	
	idy = .arg5;
	DMA_SIZE_6 = idy;
	
	MDMAEN = 0x40;

.endmacro

.macro SNDK_memset

	WMADD = .arg1;
	WMADDH = 0x7E;
	DMA_BANK_7 = .arg2;
	
	idy = .arg3;
	DMA_ADD_7 = idy;
	
	idy = .arg4;
	DMA_SIZE_7 = idy;
	
	MDMAEN = 0x80;

.endmacro

.macro  SNDK_SendOAM

	idy = 0;
	OAMADD = idy;
	
	DMA_BANK_4 =  0x7E;
	
	idy = 0xD000;
	DMA_ADD_4 = idy;
	
	idy =  0x220;
	DMA_SIZE_4 = idy;
	
	MDMAEN = 0x10;
.endmacro

.macro  SNDK_SendVRAM

	idy =  .arg1;
	VMADD = idy;
	
	DMA_BANK_0 =  #.arg2:;
	
	idy =  $.arg2:;
	DMA_ADD_0 = idy;
	
	idy =  .arg3;
	DMA_SIZE_0 = idy;
	
	MDMAEN = 1;
.endmacro

.macro  SNDK_SendVRAM_ADR

	idy =  .arg1;
	VMADD = idy;
	
	DMA_BANK_0 =  .arg2;
	
	idy =  .arg3;
	DMA_ADD_0 = idy;
	
	idy =  .arg4;
	DMA_SIZE_0 = idy;
	
	MDMAEN = 1;
.endmacro

.macro SNDK_SendCGRAM

	CGADD = .arg1;
	
	DMA_BANK_5 = #.arg2:;
	
	idy = $.arg2:;
	DMA_ADD_5 = idy;
	
	idy = .arg3;
	DMA_SIZE_5 = idy;
	
	MDMAEN = 0x20;

.endmacro

.macro SNDK_SendCGRAM_ADR

	CGADD = .arg1;
	
	DMA_BANK_5 = .arg3;
	
	idy = .arg2;
	DMA_ADD_5 = idy;
	
	idy = .arg4;
	DMA_SIZE_5 = idy;
	
	MDMAEN = 0x20;

.endmacro

//-----------------

SNES_BANK 0

proc _start:;
{
	asm "
	sei
	cld
	clc
	xce

	rep #$30
	ldx #$01FD
	txs
	phk
	pld
	lda #0
	tcd

	sep #$20
	
	;fastrom
	jml _start_jump
	_start_jump:
";

	INIDISP = 0x80; //Forced Blank
	MEMSEL = 1; //mode 3.58 MHz
	
	call SNDK_Init:;
	
	jump main:;
}

func SNDK_Joypad:;
{
	uint8 joya,joyb;
	
	acc = JOYSER0;
	joya = acc;
	if acc == 0
	{
		return;
	}
	
	acc = JOYSER1;
	joyb = acc;
	if acc == 0
	{
		return;
	}
	
	
	uint8 pad1l,pad2l,pad3l,pad4l;
	uint8 pad1h,pad2h,pad3h,pad4h;
	
	pad1l = STDCONTROL1L;
	pad2l = STDCONTROL2L;
	pad3l = STDCONTROL3L;
	pad4l = STDCONTROL4L;
	
	pad1h = STDCONTROL1H;
	pad2h = STDCONTROL2H;
	pad3h = STDCONTROL3H;
	pad4h = STDCONTROL4H;
}

proc VBlank:;
{
	asm "
		jml FastVBlank
FastVBlank:
	phd
	php
	
	phb
	pha
	phx
	phy
	
	sep #$20
";
	uint8 enable,wait;
	uint16 time;
	
	acc  = RDNMI;
	
	if enable == 1
	{
		call SNDK_VBlank:;
		
		do
		{
			
		}
		while HVBJOY & 0x01
		call SNDK_Joypad:;
		
		idy = 0;
		if wait == 0
		{
			do
			{
				idy+=1;
			}
			while HVBJOY & 0x80
		}
		time = idy
	}
	
	
	asm "
	
	ply
	plx
	pla
	plb

	plp
	pld
	
	rti
";
}

//error
proc SNES_ERROR:;
{
	asm "rti";
}

proc SNES_IRQHV:;
{
	asm "rti";
}

proc main:;
{

	SNDK_SendCGRAM 0x80,pal_data:,0x20
	
	SNDK_SendVRAM 0x6000,sprite_data:,0x200
	SNDK_SendVRAM 0x6100,sprite_data:,0x200
	
	uint8 position.x,position.y,joypad;
	spm uint8 tmp;
	
	INIDISP = 0x0F;
	NMITIMEN = 0x81;
	
	position.x = 128;
	position.y = 128;
	
	
	

	Game_Loop:
	
	if SNDK_Joypad.pad1h & SNDK_PAD_RIGHT
	{
		position.x += 1;
	}
	
	if SNDK_Joypad.pad1h & SNDK_PAD_LEFT
	{
		position.x -= 1;
	}
	
	if SNDK_Joypad.pad1h & SNDK_PAD_DOWN
	{
		position.y += 1;
	}
	
	if SNDK_Joypad.pad1h & SNDK_PAD_UP
	{
		position.y -= 1;
	}
	
	if position.x == 129
	{
		position.y += 1;
	}


	call SNDK_PrintLine: $text_hello:,#text_hello:,12,5,SNDK_FONTPAL1;

	call SNDK_Print: $text_hello:,#text_hello:,12,12,SNDK_FONTPAL1;

	
	call SNDK_Sprite:;
	
	call SNDK_SpriteDraw: position.x,position.y,4,0xC0;
	
	call SNDK_SpriteDraw2: 0,position.y,0,0;
	
	call SNDK_PrintHexa8: 0xE0,2,2,SNDK_FONTPAL1;
	
	call SNDK_PrintHexa16: 0xABCD,2,3,SNDK_FONTPAL1;

	call SNDK_WaitVBlank:;
	
	
	jump Game_Loop:;
	
	
}

funclib SNDK_PrintLine:uint16 adr,uint8 ibank,uint16 px,uint16 py,uint8 pal;
{
	lib uint8 tpal;
	tpal = pal;
	MODE16
	acc = py << 6;
	idx = acc + px;
	MODE8

	acc = @adr;
	do
	{		
		[SNDK_BG3.t1,idx] = acc-32;
		[SNDK_BG3.t2,idx] = tpal;
		adr +=1;
		idx+=2;
		
		acc = @adr;
	}
	while acc!= 0
}

funclib SNDK_Print:uint16 adr,uint8 ibank,uint16 px,uint16 py,uint8 pal;
{
	lib uint8 tpal,count;
	tpal = pal;
	MODE16
	acc = py << 6;
	idx = acc + px;
	MODE8
	count = 2;
	acc = @adr;
	do
	{		
		[SNDK_BG3.t1,idx] = acc-32;
		[SNDK_BG3.t2,idx] = tpal;
		adr +=1;
		idx+=2;
		count+=2;
		
		if @adr == 0x0A
		{
			idx +=0x40;
			idx  -= count;
			count = 0;
		}
	}
	while @adr != 0
}

.macro PRINT_HEXA
{
	acc = acc & 0xF;
	if acc < 0xA
	{
		acc += 7;
	}
	acc += 0x10;
}
.endmacro

funclib SNDK_PrintHexa8:uint8 number,uint16 px,uint16 py,uint8 pal;
{
	MODE16
	idx = py << 6;
	idx += px;
	MODE8
	
	
	acc = number>>4;
	PRINT_HEXA
	[SNDK_BG3.t1,idx] = acc;
	[SNDK_BG3.t2,idx] = pal;
	idx+=2;
	
	acc = number;
	PRINT_HEXA
	[SNDK_BG3.t1,idx] = acc;
	[SNDK_BG3.t2,idx] = pal;
}

funclib SNDK_PrintHexa16:uint16 number,uint16 px,uint16 py,uint8 pal;
{
	lib uint16 tnumber2,tnumber3;
	
	MODE16
	idx = py << 6;
	idx += px;
	
	acc = number;
	tnumber3 = acc>>4;
	tnumber2 = acc>>4;
	acc = acc>>4;
	MODE8
	
	
	PRINT_HEXA
	[SNDK_BG3.t1,idx] = acc;
	[SNDK_BG3.t2,idx] = pal;
	idx+=2;
	
	acc = tnumber2;
	PRINT_HEXA
	[SNDK_BG3.t1,idx] = acc;
	[SNDK_BG3.t2,idx] = pal;
	idx+=2;
	
	acc = tnumber3;
	PRINT_HEXA
	[SNDK_BG3.t1,idx] = acc;
	[SNDK_BG3.t2,idx] = pal;
	idx+=2;
	
	acc = number;
	PRINT_HEXA
	[SNDK_BG3.t1,idx] = acc;
	[SNDK_BG3.t2,idx] = pal;
	idx+=2;
}

.org 0x7FB0
.org 0x7FC0
SNES_HEADER

SNES_BANK 1
text_hello:
.data.s "HELLO WORLD
OK
TEST 12345
(0XFFFF) ! ?";


func SNDK_Init:;
{
	VBlank.enable = 0;
	OBJSEL = SNDK_SPR_16_32;
	BGMODE = SNDK_MODE1;
	MOSAIC = 0x00;
	BG1SC = 0x54;
	BG2SC = 0x58;
	BG3SC = 0x5C;
	BG4SC = 0x50;
	BG12NBA = 0x00; //address BG1,2 $0000
	BG34NBA = 0x44; //address BG3,4 $4000
	
	BG3H0FS = 0;
	BG3H0FS = 0;
	
	BG3V0FS = 0;
	BG3V0FS = 0;
	
	BG4H0FS = 0;
	BG4H0FS = 0;
	
	BG4V0FS = 0;
	BG4V0FS = 0;
	
	VMAINC = 0x80;
	SETINI = 0x00;
	TM = 0x17; //bg 1,2,3 ,obj enable
	COLDATA = 0xE0;
	WRIO = 0xFF;
	NMITIMEN  = 0x00; //Disable all
	SETINI = 0;
		
	TS = 0x00;
	CGSWSEL = 0x00;
	CGADSUB = 0x00;
	
	W12SEL = 0;
	W34SEL = 0;
	WOBJSEL = 0;
	M7SEL = 0;	
	TMW = 0;
	TSW = 0;
	
	WH0 = 0;
	WH1 = 0;
	WH2 = 0;
	WH3 = 0;
	
	WBGLOG = 0;
	WOBJLOG = 0;
	
	M7A = 0;
	M7B = 0;
	M7C = 0;
	M7D = 0;
	M7X = 0;
	M7Y = 0;
	
	DMA_0 = 0x01;
	DMA_BADD_0 = 0x18; //VMDATA $1
	
	DMA_1 = 0x01;
	DMA_BADD_1 = 0x18; //VMDATA $2
	
	DMA_2 = 0x01;
	DMA_BADD_2 = 0x18; //VMDATA $4
	
	DMA_3 = 0x01;
	DMA_BADD_3 = 0x18; //VMDATA $8
	
	DMA_4 = 0x02;
	DMA_BADD_4 = 0x04; //OAMDATA $10
	
	DMA_5 = 0x02;
	DMA_BADD_5 = 0x22; //CGDATA $20
	
	DMA_6 = 0x00;
	DMA_BADD_6 = 0x80; //WMDATA memcopy $40
	
	DMA_7 = 0x08;
	DMA_BADD_7 = 0x80; //WMDATA memset $80
	
	
	
	//clear RAM
	MODE16
	idy = 0x3C0;
	idx = 0;
	do
	{
		acc = 0;
		[0x200,idx] = acc;
		[0x202,idx] = acc;
		[0x204,idx] = acc;
		[0x206,idx] = acc;
		idx += 8;
	}
	loop idy == 0
	
	idy = (0xE00);
	idx = 0;
	do
	{
		acc = 0;
		[0x7E2000,idx] = acc;
		[0x7E2002,idx] = acc;
		[0x7E2004,idx] = acc;
		[0x7E2006,idx] = acc;
		
		[0x7E2008,idx] = acc;
		[0x7E200A,idx] = acc;
		[0x7E200C,idx] = acc;
		[0x7E200E,idx] = acc;
		idx += 16;
	}
	loop idy == 0
	
	MODE8	
	
	idy = 128;
	idx = 0;
	do
	{
		[SNDK_OAM0.y,idx] = 0xE0;
		idx += 4;
	}
	loop idy == 0
	
	
	
	SNDK_SendCGRAM 0x00,DATA_FONT_SNDK_P,0x20
	SNDK_SendVRAM 0x4000,DATA_FONT_SNDK_S,0x400
	


	SNDK_SendOAM
}
	
func SNDK_VBlank:;
{
	uint16 adrbg3;
	spm uint16 tmp;
	//OAM Update
	SNDK_SendOAM

	//BG3
	MODE16
	acc = adrbg3;
	acc = acc>>1;
	VMADD = acc + 0x5C00;
	
	DMA_ADD_0 = $SNDK_BG3.t1 + adrbg3;
	
	acc = adrbg3;
	acc += 0x40;
	if acc == 0x800
	{
		acc = 0;
	}
	adrbg3 = acc;
	 
	DMA_SIZE_0 = 0x40;
	MODE8
	
	DMA_BANK_0 =  #SNDK_BG3.t1;
	
	MDMAEN = 1;
}

func SNDK_ModeAlpha:;
{
	TS = 0x11;
	CGSWSEL = 0x02;
	CGADSUB = 0x42;
}

func SNDK_Sprite:;
{
	uint16 oam;
	
	idx = 0;
	oam = idx;
}

func SNDK_SpriteDraw:uint8 position.x,uint8 position.y,uint8 tile,uint8 attribute;
{
	idx = SNDK_Sprite.oam;
	[SNDK_OAM0.x,idx] = position.x;
	[SNDK_OAM0.y,idx] = position.y;
	[SNDK_OAM0.t,idx] = tile;
	[SNDK_OAM0.a,idx] = attribute;
	
	MODE16
	SNDK_Sprite.oam = idx + 8;
	MODE8
}

func SNDK_SpriteDraw2:uint8 position.x,uint8 position.y,uint8 tile,uint8 attribute;
{
	idx = SNDK_Sprite.oam;
	[SNDK_OAM0.x,idx] = position.x;
	[SNDK_OAM0.y,idx] = position.y;
	[SNDK_OAM0.t,idx] = tile;
	[SNDK_OAM0.a,idx] = attribute;
	
	[SNDK_OAM1.x,idx] = position.x+16;
	[SNDK_OAM1.y,idx] = position.y;
	[SNDK_OAM1.t,idx] = tile + 1;
	[SNDK_OAM1.a,idx] = attribute;
	
	MODE16
	SNDK_Sprite.oam = idx + 8;
	MODE8
}

func SNDK_WaitVBlank:;
{
	acc = SNDK.clockf;
	acc += 1;
	if acc == 60 //60 frames
	{
		acc = SNDK.clocks;
		acc += 1;
		if acc == 60 //60 secondes
		{
			acc = SNDK.clockm;
			acc += 1;
			if acc == 60 //60 minutes
			{
				SNDK.clockh += 1;
				acc = 0;
			}
			SNDK.clockm = acc;
			acc = 0;
		}
		SNDK.clocks = acc;
		acc = 0;
	}
	SNDK.clockf = acc;
	
	acc = SLHV;
	acc = OPVCT;
	
	MODE16
	acc = acc & 0xFF;
	WRDIVL = acc << 6;
	MODE8
	WRDIVB = 143;
	if SNDK.mcpu < SNDK.cpu
	{
		SNDK.mcpu  = SNDK.cpu;
	}
	
	if SNDK.pcpu < SNDK.cpu
	{
		SNDK.pcpu  = SNDK.cpu;
	}
	
	SNDK.cpu = RDDIVL;
	
	VBlank.enable = 1;
	asm "wai";
	VBlank.enable = 0;
}

funclib tesss:uint8 ok;
{
	spm uint8 ok1;
	lib uint8 ok2;
	ok = ok1 + ok2;;
	
	spm uint16 address;
	spm uint8 bank,tmp;
	idy = $text_hello:;
	address = idy;
	address = #text_hello:;
	
	idx = 0;
	spm uint16 idx1,idx2;
	idx1 = 0;
	idx2 = 0;
	do
	{
		tmp = @address;
		address +=1;

	}
	while tmp != 0
	
	
	idy = $text_hello:;
	address = idy;
	bank = #text_hello:;
	
	acc = address;
	acc = acc>>8;
	
	DMA_ADD_0 = $SNDK_BG3.t1 + address;
	
	DMA_ADD_0 = acc+ $SNDK_BG3.t1;
}

DATA_FONT_SNDK_S:
.incbin "lib/fontm.spr"

DATA_FONT_SNDK_P:
.incbin "lib/fontm.pal"
.incbin "lib/fontm2.pal"
.incbin "lib/fontm3.pal"
.data.w 0x7777,0;

.org 0xFFB0
.org 0xFFC0
SNES_HEADER


SNES_BANK 2

sprite_data:
.incbin "misc-01.spr"

pal_data:
.incbin "misc-01.pal"




SNES_BANK 3

SNES_BANK 4

SNES_BANK 5

SNES_BANK 6

SNES_BANK 7

SNES_BANK 8

SNES_BANK 9

SNES_BANK 10

SNES_BANK 11

SNES_BANK 12

SNES_BANK 13

SNES_BANK 14

SNES_BANK 15
.org 0x80000




